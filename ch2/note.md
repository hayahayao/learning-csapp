# 第 2 章：信息的表示和处理

## 2.1 信息存储

虚拟地址空间：实际的实现是RAM、磁盘存储、特殊硬件和操作系统软件的结合，为程序提供的是一个看上去统一的字节数组

### 2.1.1 十六进制表示法

因为一个字节=8位，为了方便表示可以4位一个16进制，这样一个字节的取值范围就是 0x00~0xFF

### 2.1.2 字数据大小

对于一个字长为 n 位的机器而言，虚拟地址的范围为 0-2^n-1，程序最多访问 2^n 字节

大多数计算机的字长为32或64位

32/64位程序：取决于该程序是如何编译的，而不是其运行的机器类型
- c语言的基本数据类型的大小受程序是如何编译的影响而变化（如 `long` 在 32 位时占 4 字节，64 位时占 8 字节；指针 `char *` 在 32 位时占 4 字节，64 位时占 8 字节）
- 为避免这种影响引入了 `int32_t` 和 `int64_t`，分别为 4 字节和 8 字节，不受编译环境影响
- 如果程序中有隐藏的对字长的影响（如指针等），则会对可移植性造成影响

### 2.1.3 寻址和字节顺序

- 对于跨越多字节的程序对象（如前面说述的 `int` 等），我们必须建立两个规则：这个对象的地址是什么、在内存中如何排列这些字节
- 在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为使用字节中最小的地址（例如 `int` 变量 x 的地址时 0x100，那么（32位时），x 的四个字节会被存储在内存的 0x100 0x101 0x102 0x103 位置）
- 小端法和大端法：两种排列字节的规则，小端法将最低有效字节排在最前面，大端法则相反（例如 0x01234567，最低有效字节为 0x67，则从 0x100-0x103 排列的话，小端法为 0x67 0x45 0x23 0x01，大端法为 0x01 0x23 0x45 0x67）
- 字节序会影响以下场景
  - 网络发送二进制数据
  - 阅读汇编代码中的整数数据字节序列
  - 编写规避正常类型系统的程序时（强制类型转换/联合等，使得一种数据类型引用一个别的类型的对象。例如强制类型转换，并不会改变真实的数据，而是告诉编译器以另一种新的数据类型来看待该数据，因此会受字节序影响）

### 2.1.4 表示字符串

c 中的字符串被编码为一个以 `null` 字符结尾的字符数组

### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的

从机器的角度看，程序仅仅是字节序列，及其没有关于原始源程序的任何信息

### 2.1.6 布尔代数简介

- ~ 非
- & 与
- | 或
- ^ 异或

### 2.1.7 C 语言中的位级运算

c 语言支持按位布尔运算

常见用法：掩码运算

### 2.1.8 C 语言中的逻辑运算

|| && !

逻辑运算具有短路特点

### 2.1.9 C 语言中的移位运算

- `<<` 左移：丢弃左边，并在右边补零
- `>>` 
  - 逻辑右移：左边补0
  - 算术右移：左边补最高有效位的值


## 2.2 整数表示

### 2.2.1 整型数据类型

整型数据类型：表示有限范围内的整数，包括 `[signed/unsigned] char short long int`，以及 `[u]int32_t [u]int64_t`

### 2.2.2 无符号数的编码

即该数的二进制表示

w 位所能表示的范围：[0, 2^w-1]

### 2.2.3 补码编码

最高位为符号位，0正1负，后面跟二进制表示

w 位所能表示的范围：[-2^(w-1), 2^(w-1)-1]

注意：
- 补码的范围是不对称的，|Tmin| = |Tmax| + 1，因为最高位为 0 表示的是*非负数*（包括0）
- 无符号的最大值 Umax = 2Tmax + 1
- 对于非负数 x，-x 可以用 2^w - x 来计算（这正是补码名字的来源）

### 2.2.4 有符号数和无符号数之间的转换

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式

所以可以推导出一些原理：
- 将有符号数（补码）转换为无符号数 T2U(x)：x >= 0 时，无符号数解释出来的数与原数 x 相同；x < 0 时，无符号数解释出来的为 x+2^w
- 将无符号数转换为有符号数（补码） U2T(u)：u <= Tmax 时，有符号数解释出来的数与原数 u 相同；u > Tmax 时，有符号数解释出来的为 u-2^w（即发生溢出）

### 2.2.5 C 语言中的有符号数与无符号数

- 显式类型转换：强制转换
- 隐式类型转换：
  - 一种类型的表达式被赋值给另一种类型的变量时，会转换为被赋值变量的类型
  - printf 控制输出类型
  - 执行运算时，如果一个运算数是有符号一个是无符号，会将有符号的转换为无符号，并假设这两个数都是非负，来进行计算（因此在 `< >` 等关系运算符中会产生一些非直观的结果）

### 2.2.6 扩展一个数字的位表示

将一个字长较短的数据类型转换为较长的，即扩展：
- 无符号数：零扩展，即在前面补 0
- 补码数：符号扩展，在前面补最高有效位

### 2.2.7 截断数字

将字长较长的转换为较短的，即截断，丢弃高位，产生的结果：
- 无符号数 x：截断为 k 位，结果为 x mod 2^k
- 补码数 x：截断为 k 位，结果为 U2T(x mod 2^k)

### 2.2.8 关于有符号数与无符号数的建议

- 不建议使用无符号数（有符号数到无符号数的隐式类型转换经常会导致错误）
- 如果只是把字看成位的集合而没有任何数字意义时可以使用无符号数，如 flag 数组、地址、模运算/高精度运算等

## 2.3 整数运算

### 2.3.1 无符号加法

溢出时截断，即 x + y 溢出时，结果得到 x + y - 2^w

### 2.3.2 补码加法

同样溢出时截断，向上溢出时得到 x+y-2^w，向下溢出时得到 x+y+2^w

### 2.3.3 补码的非

Tmin 的非是其自身，其余数 x 的非都是 -x

计算：
- 每一位求补，再对结果加一。即 -x 与 ~x+1 相同
- 假设 k 是最右边 1 的位置，对位 k 左边的所有位取反

### 2.3.4 无符号乘法

溢出时截断，得到 (x * y) mod 2^w

### 2.3.5 补码乘法

溢出时截断，结果为 U2T((x * y) mod 2^w)（截断方法即补码数的截断方法）

### 2.3.6 乘以常数

由于机器上进行整数乘法指令比进行其他整数运算（加减法/位级运算/移位等）都要慢，因此编译器采取了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法
- 乘以 2 的幂：x * 2^k = x << k（左移 k 位）
- 乘以其他常数：将常数拆成 2 的幂的加减组合，具体拆的方法是将这个数写为二进制 [(0...0)(1...1)(0...0)...(1...1)]，然后考虑每一段连续的 1，从 n 到 m 连续的 1 可以写成 (x << n) + (x << (n-1)) + ... + (x << m) 或者 (x << (n+1)) - (x << m)，然后把这些连续的 1 相加

### 2.3.7 除以 2 的幂

- 无符号数：右移 k 位，即 x >> k，得到的结果总是向下舍入
- 补码数：*算术*右移 k 位，此时得到的也都是向下舍入的结果，对于非负数没问题，但对于负数，正确的表现是向上舍入，所以需要加上一个偏置量再算术右移 k 位： (x + (1 << k) - 1) >> k
- 总结：非负数直接 x >> k，负数 (x + (1 << k) - 1) >> k

### 2.3.8 关于整数运算的最后思考

计算机执行的“整数“运算实际上是一种模运算形式

## 2.4 浮点数

### 2.4.1 二进制小数 

每一位分别代表 ..., 4, 2, 1, 1/2, 1/4, 1/8, ...

### 2.4.2 IEEE 浮点表示

V = (-1)^s * M * 2^E，其中：
- s：符号（sign），0 正 1 负
- M：尾数（由下面的 frac 计算得出），是一个二进制小数
- E：阶码（由下面的 exp 计算得出），作用是对浮点数加权，权重是 2^E

常见格式：
- 单精度 `float`：
  - s 位于 31 位（1 位）
  - exp 位于 30-23 位（8 位）
  - frac 位于 22-0 位（23 位）
- 双精度 `double`：
  - s 位于 63 位（1 位）
  - exp 位于 62-52 位（11 位）
  - frac 位于 51-0 位（52 位）

值的情况：（以单精度为例）
- 规格化的值：exp != 0 && exp != 255（即非全 0 也非全 1）
  - E = e - Bias，其中：
    - Bias = 2^(k-1)-1（k-1 为 exp 的长度，即单精度时 Bias=127，双精度时 Bias=1023）
    - e 为无符号数 exp
  - M = 1 + f，其中：
    - f 为 frac 在前面加一个小数点，即 0.frac(n-1) frac(n-2) ... frac0
- 非规格化的值：exp 全 0
  - E = 1 - Bias
  - M = f
  - 非规格化数可以用来表示 0（正负0）以及 0 附近的数（逐渐下溢，即表示的可能数值是均匀分布在 0 附近的）
- 特殊值
  - exp 全 1，frac 全 0：表示无穷大
  - exp 全 1，frac 非 0：表示 NaN

### 2.4.3 数字示例

（以单精度为例）
- 0：exp = 全0，frac = 全0
- 最小非规格化数：exp = 全0，frac = 0...01，值为 2^(-23) * 2^(-126)
- 最大非规格化数：exp = 全0，frac = 1...11，值为 (1 - ε) * 2^(-126)
- 最小规格化数：exp = 0...01，frac = 0...00，值为 1 * 2^(-126)
- 1：exp = 01...11，frac = 0...00，值为 1 * 2^0
- 最大规格化数：exp = 11...10，frac = 1...11，值为 (2 - ε) * 2^127

### 2.4.4 舍入

舍入：用一种系统的方法，找到最接近值 x 的匹配值 x'，这个 x' 可以用浮点形式表示出来

四种舍入方式：
- 向偶数舍入：首先向最接近的值舍入；如果是中间数值，则将数字向上或向下舍入，使得结果的最低有效数字是偶数
- 向零舍入：将正数向下舍入，负数向上舍入
- 向下舍入
- 向上舍入

二进制小数可以采用*向偶数舍入*

### 2.4.5 浮点运算

IEEE 标准要求浮点运算得到的结果为：将浮点值 x 和 y 看做实数，要求运算结果为 实数运算的精确结果再舍入

实际上，浮点单元并不会执行两个实数的精确计算，而只要保证得到一个正确的舍入结果就可以了

> 阿贝尔群：满足一般的群公理（结合律、单位元、逆元），还要满足交换律

加法：
- 阿贝尔群：
  - 整数（包括无符号数和补码）加法是阿贝尔群
  - 实数加法也是阿贝尔群
  - 然而浮点数加法不是阿贝尔群，因为不满足*结合律*，且两个特殊值（无穷/NaN）没有逆元
- 单调性：如果 a >= b，那么对于任意 a b x（除 NaN），都有 x + a >= x + b
  - 实数、整数加法满足单调性
  - 浮点加法满足单调性
  - 无符号、补码加法不满足单调性

乘法：
- 封闭 可交换 有单位元
- 不满足结合律 在加法上不具备分配性
- 满足单调性（无符号、补码乘法不满足）

### 2.4.6 C 语言中的浮点数

在 `int float double` 中进行类型转换时：（假设 `int` 是 32 位的）
- 原则：可表示值范围不够 - 发生溢出；精度不够 - 发生舍入
- int -> float：数字不会溢出，但可能被舍入
- int/float -> double：能够保留精确的数值
- double -> float：可能溢出成正/负无穷，也可能被舍入
- float/double -> int：向零舍入，也可能会溢出
