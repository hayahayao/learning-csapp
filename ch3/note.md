# 第 3 章：程序的机器级表示

- 计算机执行*机器代码*，编译器生成机器代码
- GCC C 语言编译器以*汇编代码*的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令
- 之后 GCC 调用*汇编器*和*链接器*，根据汇编代码生成可执行的机器代码

## 3.1 历史观点

Intel 处理器系列俗称 x86

AMD

## 3.2 程序编码

gcc 命令：调用一整套程序，将源代码转化成可执行代码
- C 预处理器：扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明制定的宏
- 编译器：产生源文件的汇编代码（xxx.c -> xxx.s）
- 汇编器：将汇编代码转化成二进制目标代码文件（xxx.o）
  - *目标代码*是机器代码的一种形式，它包含所有指令的二进制表示，但还没有填入全局值的地址
- 链接器：将目标代码文件与实现库函数（例如 `printf`）的代码合并，并产生最终的可执行代码文件
  - *可执行代码*是机器代码的第二种形式，也就是处理器执行的代码格式

### 3.2.1 机器级代码

机器级编程的两种抽象：
- 由*指令集体系结构或指令集架构*（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为
  - 它定义了处理器状态、指令的格式、以及每条指令对状态的影响
  - 大多数 ISA，包括 x86-64，将程序的行为描述成好像每条指令都是按顺序执行的（实际的处理器硬件更为复杂，是并发执行多条指令的，但能保证整体行为与 ISA 指定的顺序执行的行为完全一致）
- 机器级程序使用的内存地址是*虚拟地址*，提供的内存模型看上去是一个非常大的字节数组（实际的存储器系统是将多个硬件存储器和操作系统软件组合起来）

x86-64 的机器代码中，一些通常对 C 语言程序员隐藏的处理器状态都是可见的：
- 程序计数器：（通常称为 PC，在 x86-64 中用 `%rip` 表示）给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件：包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址或整数数据，可以被用来记录某些重要的程序状态/保存临时数据等
- 条件码寄存器：保存着最近执行的算术或逻辑指令的状态信息。他们用来实现控制或数据流中的条件变化
- 一组向量寄存器：存放一个或多个整数或浮点数值

程序内存：
- 包含程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，用户分配的内存块
- 程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的
- 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址

### 3.2.2 代码示例

反汇编器：根据机器代码产生一种类似汇编代码的格式

- x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，反之需要的字节数较多
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令

### 3.2.3 关于格式的注解

## 3.3 数据格式

- （1 字节 = 8 位）
- 整型数/指针：字（word）- 16 位；双字（double words）- 32 位；四字（quad words）- 64 位
  - int-4字节-双字-后缀l
  - long-8字节-四字-后缀q
  - short-2字节-字-后缀w
  - char-1字节-字节-后缀b
- 浮点数：单精度值 双精度值
  - float-4字节-单精度-后缀s
  - double-8字节-双精度-后缀l

## 3.4 访问信息

- 一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的*通用目的寄存器*，这些寄存器用来存储整型数据和指针
- 名字都以 `%r` 开头，`%rax - %rsp` + `%r8 - %r15`
- 有一组标准的编程规范控制者如何使用寄存器来管理栈、传递函数参数、从函数的返回值、以及存储局部和临时数据（例如 `%rsp` 用作栈指针，指明运行时栈的结束位置）

### 3.4.1 操作数指示符

操作数的类型：
- 立即数：表示常数值，`$Imm`
- 寄存器：表示某个寄存器的内容，`ra`
- 内存引用：根据计算出来的地址访问某个内存位置，有不同的寻址模式：
  - 绝对寻址：`Imm`
  - 间接寻址：`(ra)`
  - 基址+偏移量寻址：`Imm(rb)` 意为地址 `Imm+R[rb]`（立即数 Imm 加上寄存器 rb 中的内容）
  - 变址寻址：
    - `(rb, ri)` 意为地址 `R[rb]+R[ri]`
    - `Imm(rb, ri)` 意为地址 `Imm+R[rb]+R[ri]`
  - 比例变址寻址：\
    - `(, ri, s)` 意为地址 `R[ri]*s`
    - `Imm(, ri, s)` 意为地址 `Imm+R[ri]*s`
    - `(rb, ri, s)` 意为地址 `R[rb]+R[ri]*s`
    - `Imm(rb, ri, s)` 意为地址 `Imm+R[rb]+R[ri]*s`

### 3.4.2 数据传送指令

`MOV S, D`：将数据从 S 复制到 D（D <- S）
- S 指定的值是一个立即数，存储在寄存器或内存中
- D 指定一个位置（寄存器或内存地址）
- x86-64 限制两个地址不能都指向内存地址（如果需要将一个值从一个内存位置复制到另一个内存位置需要两条指令，先将源值加载到寄存器中再将寄存器的值写入目的地址）

`MOVZ S, R`：将 S 中的数据*零扩展*后复制到 R
`MOVS S, R`：将 S 中的数据*符号扩展*后复制到 R

### 3.4.3 数据传送示例

- C 语言中所谓的指针其实就是地址，间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器
- 函数中的局部变量通常保存在寄存器而不是内存中，因为访问寄存器要比访问内存快得多

### 3.4.4 压入和弹出栈数据

- 栈顶：插入和弹出元素的那一端
- 在 x86-64 中，程序栈存放在内存中的某个区域
- 栈向下增长，栈顶元素的地址是所有栈元素地址中最低的
- 栈指针 `%rsp` 保存着栈顶元素的地址

`pushq S`：将四字压入栈
- 效果：`R[%rsp] <- R[%rsp] - 8`; `M[R[%rsp]] <- S`
- 栈指针减 8（向下移动），然后将值写到新的栈顶地址

`popq D`：将四字弹出栈
- 效果：`D <- M[R[%rsp]]`; `R[%rsp] <- R[%rsp] + 8`

## 3.5 算术和逻辑操作

### 3.5.1 加载有效地址

`leaq S, D`：加载有效地址（load effective address），从内存读数据到寄存器
- 实际上没有引用内存，而是将 &S 写入到 D（&S：产生内存引用 S 的指针）
- D 必须为一个寄存器
- 其他灵活用法：执行加法和有限形式的乘法
  - 例如寄存器 `%rdx` 的值为 x，那么指令 `leaq 7(%rdx, %rdx, 4), %rax` 将设置寄存器 `%rax` 的值为 5x+7

### 3.5.2 一元和二元操作

一元操作：
- `INC D`：D <- D + 1，加一
- `DEC D`：D <- D - 1，减一
- `NEG D`：D <- -D，取负
- `NOT D`：D <- ~D，取补

二元操作：
- `ADD S, D`：D <- D + S
- `SUB S, D`：D <- D - S
- `IMUL S, D`：D <- D * S
- `XOR S, D`：D <- D ^ S，异或
- `OR S, D`：D <- D | S，或
- `AND S, D`：D <- D & S，与

### 3.5.3 移位操作

k：移位量，可以是 Imm，也可以放在单字节寄存器 `%cl` 中
- `SAL k, D`：D <- D << k，左移
- `SHL k, D`：D <- D << k，左移（等同于 SAL）
- `SAR k, D`：D <- D >> k，算术右移
- `SHR k, D`：D <- D >> k，逻辑右移

### 3.5.4 讨论

- 除右移操作区分有符号和无符号数之外，其他算术/逻辑指令都是既可以用作无符号运算，也可以用作补码运算
- 通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值

### 3.5.5 特殊的算术操作

八字：oct word，16 字节（128 位）的数（两个四字相乘会得到 16 字节）

全乘法：`%rax` 存放乘法的一个参数，另一个作为指令的源操作数给出。乘积存放在 `%rdx`（高64位）和 `%rax`（低64位）中
- `imulq S`：`R[%rdx]:R[%rax] <- R[%rax] * S`，有符号全乘法
- `mulq S`：`R[%rdx]:R[%rax] <- R[%rax] * S`，无符号全乘法
- `cqto`：`R[%rdx]:R[%rax] <- 符号扩展(R[%rax])`，转换为八字
- 在实际运算中，储存乘积需要两个 movq 指令，一个存储低 8 个字节，一个存储高 8 个字节

除法：`R[%rdx]:R[%rax]` 作为被除数，除数在指令中给出。指令将商存储在 `%rax` 中，余数存储在 `%rdx` 中
- `idivq S`：有符号除法
- `divq S`：无符号除法
- 除法的效果：`R[%rdx] <- R[%rdx]:R[%rax] mod S`; `R[%rax] <- R[%rdx]:R[%rax] / S`
- 所有的除法都是由这个指令实现的，与 imul 有两种不同
- 一般的被除数也是四字的，存在 %rax 中，%rdx 需要进行相应扩展，无符号运算时进行零扩展，有符号运算时进行符号扩展（这个符号扩展可以通过 cqto 指令实现）

## 3.6 控制

### 3.6.1 条件码

CPU 维护者一组单个位的条件码寄存器，描述了最近的算术或逻辑操作的属性：
- CF：进位标志，最近的操作使最高位产生了进位，可用来检查无符号操作的溢出
- ZF：零标志，最近的操作得到的结果为零
- SF：符号标志，最近的操作得到的结果为负数
- OF：溢出标志，最近的操作导致一个补码溢出（正溢出或负溢出）

leaq 指令不改变任何条件码，因为它是用来进行地址计算的

只设置条件码而不改变任何其他寄存器的两个指令：
- `CMP S1, S2`：基于 S2-S1 比较
- `TEST S1, S2`：基于 S1&S2 测试

### 3.6.2 访问条件码

条件码通常不会直接读取，常见的使用方法：
- 根据条件码的某种组合，将一个字节设置为0/1
  - `SET D` 指令
  - D 是底位单字节寄存器元素之一，为了得到 32/64 位的值，需要在 SET 指令后对这个寄存器的高位清零
- 条件跳转到程序的某个其他部分
- 有条件地传送数据

### 3.6.3 跳转指令

`JUMP` 指令：包括无条件和有条件跳转

### 3.6.4 跳转指令的编码

跳转地址的编码：
- PC 相对：将目标指令的地址与紧跟在跳转指令*后面*的那条指令的地址之间的差作为编码（原因是因为早期的实现中，CPU 会将更新 PC 作为执行一条指令的第一步）
- 绝对：给出“绝对”地址，用 4 个字节直接指定目标，汇编器和链接器都会选择适当的跳转目的编码

### 3.6.5 用条件控制来实现条件分支

将条件表达式和语句从 c 语言翻译成机器代码的方式：
- 条件控制
- 条件传送

条件控制可以翻译如下：
```
// c 语言中的 if-else 语句通用模板
if (test-expr)
  then-statement
else
  else-statement

// 汇编实现的控制流（c 语言描述）
  t = test-expr;
  if (!t)
    goto false;
  then-statement
  goto done;
false:
  else-statement
done:
```

### 3.6.6 用条件传送来实现条件分支

条件转移实现条件分支：计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个
- 因为现代处理器通过使用流水线来获得高性能，即重叠连续指令的步骤
- 要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令
- 而当机器遇到条件跳转时，处理器采用分支预测技术来猜测每条跳转指令是否执行，而错误预测会导致性能严重下降
- 使用条件转移而不是条件控制，控制流不依赖数据，会使得处理器更容易保持流水线是满的

条件传送指令：
- `CMOVE S, R`：当满足某个条件时进行传送

```
// c 
v = test-expr ? then-expr : else-expr;

// 条件控制
  if (!test-expr)
    goto false;
  v = then-expr;
  goto done;
false:
  v = else-expr;
done:

// 条件传送
v = then-expr;
ve = else-expr;
t = test-expr;
if (!t) v = ve;
```

注意：
- 不是所有的条件表达式都可以用条件传送来编译，因为 then-expr 和 else-expr 总会被求值，因此必须保证两者都没有可能产生副作用或错误
- 使用条件传送也不总是会提高代码的效率。例如 then-expr 和 else-expr 都需要大量的计算时，会造成很多计算工作被浪费了。编译器必须权衡浪费的计算和由于分支预测错误造成的性能处罚之间的相对性能（实际上编译器也缺乏足够的信息来做出可靠的决定，一般 GCC 只会在两个表达式都很容易计算时使用条件传送，其他情况都还是会使用条件控制）

### 3.6.7 循环

do-while 循环：
```
// c
do
  body-statement
  while (test-expr);

// 汇编
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
```

while 循环：
```
// c
while (test-expr)
  body-statement

// 翻译：跳转到中间策略
  goto test;
loop:
  body-statement
test:
  t = test-expr;
  if (t)
    goto loop;

// 翻译：guarded-do 策略
t = test-expr;
if (!t)
  goto done;
do // 这个 do-while 循环可以进一步翻译
  body-statement
  while (test-expr);
done:
```

guarded-do 方法：首先用条件分支，如果初始条件不成立就跳过循环，把代码变换成 do-while 循环。利用这种实现策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足

for 循环：
```
// c
for (init-expr; test-expr; update-expr)
  body-statement
// 根据 c 语言标准，等价于 while 循环
init-expr;
while (test-expr) {
  body-statement
  update-expr;
}

// 跳转到中间策略
  init-expr;
  goto test;
loop:
  body-statement
  update-expr;
test:
  t = test-expr;
  if (t)
    goto loop;

// guarded-do 策略
  init-expr;
  t = test-expr;
  if (!t)
    goto done;
loop:
  body-statement
  update-expr;
  t = test-expr;
  if (t)
    goto loop;
done:
```

### 3.6.8 switch 语句

跳转表：一个数组，表项 i 是一个代码段的地址，这个代码段实现当 switch 索引值等于 i 时程序应该采取的动作
- 优点：执行 switch 语句的时间与 switch case 的数量无关
- GCC 根据 switch case 数量和 switch case 的稀疏程度来翻译 switch 语句，当 switch case 数量较多且值的跨度范围较小时，就会使用跳转表

## 3.7 过程

假设过程 P 调用过程 Q，Q 执行后返回到 P。这个过程包括下面机制：
- 传递控制：在进入到过程 Q 的时候，PC 必须被设置为 Q 的代码的起始地址，然后在返回时，要把 PC 设置为 P 中调用 Q 后面那条指令的地址
- 传递数据：P 必须能向 Q 提供一个或多个参数，Q 必须能向 P 返回一个值
- 分配和释放内存：在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间

### 3.7.1 运行时栈

栈帧：当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，称为过程的栈帧。

通用的栈帧结构：（自底到顶）
- 较早的帧
- 调用函数 P 的帧
  - P 自身所需的
  - 传入 Q 的参数（通过寄存器可以传递 6 个参数，如需更多则需要存在 P 自身的栈帧中）
  - 返回地址（3.7.2 中所述的地址 A）
- 正在执行的函数 Q 的帧
  - 被保存的寄存器
  - 局部变量
  - 参数构造区（即 n-7 个参数）

大多数过程的栈帧都是定长的，在过程的开始就分配好了

### 3.7.2 转移控制

- P 到 Q：只需将 PC 设置为 Q 代码的起始位置
- Q 到 P：处理器必须记录好它需要继续执行 P 的代码位置（P 中调用 Q 后面那条指令的地址）

对应指令：
- `call Q`：把地址 A（即上述的 P 中调用 Q 后面那条指令的地址，称为返回地址）压入栈中，并将 PC 设置为 Q 的起始地址
  - call 的操作数可以是直接地址，也可以是间接的（间接地址记为 `*`+操作数指示符）
- `ret`：从栈中弹出地址 A，并把 PC 设置为 A

### 3.7.3 数据传送

通过寄存器最多可以传递 6 个整型（即整数和指针）参数，超过 6 个的部分要通过栈来传递，按照第 n-7 的顺序依次压入栈

### 3.7.4 栈上的局部存储

局部数据需要放到内存（栈）中的情况：
- 寄存器不足够存放所有的本地数据
- 对一个局部变量使用地址运算符 `&`，因此必须能够为它产生一个地址
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到

过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧的一部分，即“局部变量”

### 3.7.5 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。需要保证当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此 x86-64 采用了一组统一的寄存器使用惯例，所有的过程都必须遵循：
- `%rbx, %rbp, %r12-%r15` 为被调用者保存寄存器，当 P 调用 Q 时，Q 必须保存这些寄存器的值，保证它们的值在返回时与 Q 被调用时是一致的
- 所有其他的寄存器，除栈指针 `%rsp`，都为调用者保存寄存器，任何函数都能修改它们（P 在调用 Q 之前需要自己保存好它们的值）

### 3.7.6 递归过程

栈自然实现了递归，每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量也不会相互影响

## 3.8 数组分配和访问

### 3.8.1 基本原则

对于数据类型 T 和整型常数 N，声明 `T A[N]`，起始位置表示为 `xA`。这个声明有两个效果：
- 在内存中分配一个 L*N 字节的连续区域（L 是数据类型 T 的大小，单位为字节）
- 引入了标示符 A，可以用 A 来作为指向数组开头的指针，这个指针的值就是 xA。可以用 0-N-1的整数索引来访问该数组元素，数组元素 i 会被存放在地址为 xA+L*i 的地方

### 3.8.2 指针运算

> C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。
>
> 对于一个表示某个对象的表达式 `Expr`，`&Expr` 给出该对象地址的一个指针；对于一个表示地址的表达式 `AExpr`，`*AExpr` 给出该地址的值

因此，数组引用 `A[i]` 等同于表达式 `* (A+i)`

### 3.8.3 嵌套的数组

对于一个声明如下的数组：`T D[R][C]`，它的数组元素 `D[i][j]` 的内存地址为 `&D[i][j] = xD + L(C * i + j)`

### 3.8.4 定长数组

C 语言编译器能够优化定长多位数组上的操作代码：
- 去掉整数索引
- 将所有的数组引用都转换成指针间接引用

### 3.8.5 变长数组

变长数组可以声明如 `int A[expr1][expr2]`，在遇到这个声明时，通过对表达式 expr1 和 expr2 求值来确定数组的维度

引用定长数组可以使用 leaq 计算索引如 n*i+j ，但变长数组由于 n 是不确定的（运算时存在寄存器中，代码并不知道 n 是多少），所以这个求值必须使用 mul 乘法指令。在一些处理器中，乘法会导致严重的性能惩罚，但这无法避免

在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算：GCC 能够识别出程序访问多维数组元素的步长，生成的代码会避免直接使用乘法

## 3.9 异质的数据结构

- 结构 `struct`：将多个对象集合到一个单位中
- 联合 `union`：允许用几种不同的类型来引用一个对象

### 3.9.1 结构

- `struct` 所有的组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址
- 编译器维护关于每个结构类型的信息，指示每个字段的字节偏移
- 编译器以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用

结构的各个字段的选取完全是编译时处理的，机器代码不包含关于字段声明或字段名字的信息

### 3.9.2 联合

联合中每个字段的偏移量都是 0，总的大小等于它最大字段的大小

联合的用处：
- 如果事先知道一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合而不是结构的一部分，可以减少分配空间的总量
- 用来访问不同数据类型的位模式

### 3.9.3 数据对齐

对齐限制：许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K（通常是2/4/8）的倍数
- 简化了形成处理器和内存系统之间接口的硬件设计

Intel 建议对齐数据以提高内存系统的性能，对齐原则：任何 K 字节的基本对象的地址必须是 K 的倍数

结构：
- 对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求
- 结构本身对它的起始地址也有一些对齐要求
- 编译器结构的末尾可能需要一些填充，这样结构数组中的每个元素都会满足它的对齐要求

## 3.10 在机器级程序中将控制与数据结合起来

### 3.10.1 理解指针

- 每个指针都对应一个类型
  - 这个类型表明该指针指向的是哪一类对象
  - 指针类型不是机器代码中的一部分，它们是 C 语言提供的一种抽象，帮助程序避免寻址错误
- 每个指针都有一个值
  - 这个值是某个指定类型的对象的地址
- 指针用 `&` 运算符创建
  - 因为 leaq 指令是设计用来计算内存引用的地址的，`&` 运算符的机器代码实现常常用这条指令来计算表达式的值
- `*` 操作符用于间接引用指针
  - 其结果是一个值，它的类型与该指针的类型一致
  - 间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取
- 数组与指针紧密联系
  - 一个数组的名字可以像一个指针变量一样引用
  - 数组引用 与 指针运算和间接引用 有一样的效果
  - 数组引用 和 指针运算 都需要用对象大小对偏移量进行伸缩
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值
  - 强制类型转换的一个效果是改变指针运算的伸缩
- 指针也可以指向函数
  - 者提供了一个强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用
  - 函数指针的值是该函数机器代码表示中第一条指令的地址

### 3.10.2 应用：使用 GDB 调试器

### 3.10.3 内存越界引用和缓冲区溢出

C 对于数组引用不进行任何边界检查；而且局部变量和状态信息（例如保存的恶寄存器值和返回地址）都存放在栈中 -> 对越界的数组元素进行写操作，会破坏存储在栈中的状态信息

*缓冲区溢出*（buffer overflow）：计算机对接收的输入数据没有进行有效的检测（理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符），向缓冲区内填充数据时超过了缓冲区本身的容量，而导致数据溢出到被分配空间之外的内存空间，使得溢出的数据覆盖了其他内存空间的数据。
- 破坏栈上保存的返回地址等状态值，ret 时会跳转到一个完全意想不到的位置
- 让程序执行它本来不愿执行的函数。通常输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码（称为攻击代码），另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址，那么 ret 时就会跳转到攻击代码
  - 在一种攻击形式中，攻击代码会使用系统调用启动一个 shell 程序，给攻击者提供一组操作系统函数
  - 在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，（表面上）正常返回到调用者

### 3.10.4 对抗缓冲区溢出攻击

GCC 提供的机制：

1.栈随机化：
- 为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分
- 产生这个指针需要知道攻击字符串放置的*栈地址*
- 在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。导致许多系统都容易受到同一种病毒的攻击，称作安全单一化现象
- *栈随机化*思想使得栈的位置在程序每次运行时都有变化
- 实现方式：程序开始时，在栈上分配一段 0-n 字节之间的随机大小的空间。程序不使用这段空间，但会导致程序每次执行时后续的栈位置发生变化
- 注意：分配的 范围 n 必须足够大，才能获得足够多的栈地址变化；但是又要足够小，不至于浪费程序太多的空间
- 在 Linux 系统中，栈随机化已经变成了标准行为，属于地址空间布局随机化（ASLR）技术的一种。
- 破解：空操作雪橇，即在实际的攻击代码之前插入一段很长的 nop 指令，只要攻击者能够猜中这段序列中的某个地址，程序就会经过这段序列，到达攻击代码（例如对于 n=2^23 的随机化，建立一个 256 字节的空操作雪橇，那么枚举 2^15 个起始地址就能破解）

2.栈破坏检测
- GCC 在产生的代码中加入*栈保护者*机制，来检测缓冲区越界
- 其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值（哨兵值，是在程序每次运行是随机生成的），在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或该函数调用的某个函数的某个操作改变了，如果是，那么程序异常中止

3.限制可执行代码区域
- 消除攻击者向系统中插入可执行代码的能力，即限制哪些内存区域能够存放可执行代码
- 在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的，其他部分可以被限制为只允许读和写

### 3.10.5 支持变长栈帧

以上的机器级代码都是编译器能够预先确定需要为栈帧分配多少空间的，然而有些函数需要的局部存储是变长的（例如调用 `alloca`；代码声明一个局部变长数组等）

x86-64 代码使用寄存器 `%rbp` 作为帧指针
- 在为调用函数分配栈空间前，存储了返回地址后，再存储当前的 `%rbp`
- 之后在函数的整个执行过程中，都使得 `%rbp` 指向那个时刻栈的位置，然后用固定唱的的局部变量相对于 `%rbp` 的偏移量来引用它们
- 函数结尾，leave 指令释放整个栈帧

## 3.11 浮点代码

处理器的浮点体系结构：
- 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成
- 对浮点数据操作的指令
- 向函数传递浮点数参数和从函数返回浮点数结果的规则
- 函数调用过程中保存寄存器的规则
  
存放浮点数的寄存器（YMM 寄存器）：
- `%ymm0` - `%ymm15`
- 每个 YMM 寄存器都是 256 位（32字节）
- 当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位（float）或 64 位（double）
- 低 16 字节可以作为 XMM 寄存器来访问（MM：64 位；XMM：128 位；YMM：256 位）

### 3.11.1 浮点传送和转换操作

- `VMOV`：浮点传送指令
- `VCVT`：浮点转换指令
  - `vcvttss2` `vcvttsd2`：双操作数浮点转换指令，将浮点数转换成整数
  - `vcvtsiss` `vcvtsisd`：三操作数浮点转换指令，将整数转换成浮点数
  - 两种不同的浮点格式之间转换

### 3.11.2 过程中的浮点代码

在 x86-64 中，XMM 寄存器用来向函数传递浮点数参数，以及从函数返回浮点值。
- XMM 寄存器 `%xmm0-%xmm7` 最多可以传递 8 个浮点参数，可以通过栈传递额外的浮点参数
- 函数使用寄存器 `%xmm0` 来返回浮点值
- 所有的 XMM 寄存器都是调用者保存的
- 当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过 XMM 寄存器传递，也就是说，参数到寄存器的映射取决于他们的类型和排列顺序

### 3.11.3 浮点运算操作

- 浮点数加：`vaddss` `vaddsd`
- 浮点数减：`vsubss` `vsubsd`
- 浮点数乘：`vmulss` `vmulsd`
- 浮点数除：`vdivss` `vdivsd`
- 浮点数最大值：`vmaxss` `vmaxsd`
- 浮点数最小值：`vminss` `vminsd`
- 浮点数平方根：`sqrtss` `sqrtsd`

### 3.11.4 定义和使用浮点常数

AVX 浮点操作不能以立即数值作为操作数，编译器必须为所有的常量值分配和初始化存储空间，然后代码再把这些值从内存读入

### 3.11.5 在浮点代码中使用位级操作

- 位级异或：`vxorps` `xorpd`
- 位级与：`vandps` `andpd`

### 3.11.6 浮点比较操作

- 比较单精度值：`vuvomiss`
- 比较双精度值：`vuvomisd`

浮点比较指令会设置三个条件码：零标志位 ZF，进位标志位 CF 和奇偶标志位 PF（奇偶标记位：对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有偶数个 1）；对于浮点比较，当两个操作数中任一个是 NaN 时）

### 3.11.7 对浮点代码的观察结论

- 用 AVX2 位浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格：都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数
- 处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂之处，AVX2 代码包括许多比只执行整数运算的函数更加不同的指令和格式
- AVX2 还有能力在封装好的数据上执行并行操作，使计算执行得更快
