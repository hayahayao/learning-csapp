# 第 4 章：处理器体系结构

## 4.1 Y86-64 指令集体系结构

我们定义一个指令集体系结构（称为 Y86-64）

### 4.1.1 程序员可见的状态

程序员可见状态：指处理器状态的某些部分，Y86-64 程序中的每条指令都会读取或修改这个状态的某些部分。在处理器实现中，我们要保证机器级程序能够访问程序员可见状态

定义 Y86-64 的状态：
- 15 个程序寄存器：`%rax %rcx %rdx %rbx %rsp %rbp %rsi %rdi %r8-%r14`
  - 每个寄存器存储一个 64 位的字
  - `%rsp` 为栈指针
  - 其他寄存器没有固定含义或固定值
- 3 个一位条件码
  - ZF：零标志
  - SF：符号标志
  - OF：溢出标志
- PC
- 内存：Y86-64 程序用虚拟地址来引用内存位置
- 状态码 Stat：表明程序执行的总体状态，指示是正常运行，还是出现某种异常

### 4.1.2 Y86-64 指令

- halt
- nop
- movq 指令：rrmovq irmovq rmmovq mrmovq（第一个字母指明源的类型，第二个字母指明目的的类型）
- 整数操作指令：addq subq andq xorq
- 跳转指令：jmp jle jl je jne jge jg
- 条件传送指令：cmovle cmovl cmove cmovne cmovge cmovg
- call ret
- pusq popq

### 4.1.3 指令编码

- 每条指令需要 1-10 个字节不等
- 每条指令的第一个字节表明指令的类型（这个字节分为两部分，高 4 位是代码部分，低 4 位是功能部分，功能部分用于一组相关指令共用一个代码时）

寄存器标示符：0.5字节，15 个寄存器每个都有一个相对应的标示符

常数字：8 字节

指令集的一个重要性质就是字节编码必须有唯一的解释，任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程序

### 4.1.4 Y86-64 异常

状态码 Stat：
- 1 AOK：正常操作
- 2 HLT：处理器执行 halt 指令
- 3 ADR：遇到非法地址
- 4 IHS：遇到非法指令

### 4.1.5 Y86-64 程序

### 4.1.6 一些 Y86-64 指令的详情

- `pushq %rsp`：压入 `%rsp` 的原始值，而非 -8 后的值
- `popq %rsp`：将 `%rsp` 置为从内存中读出的值，而非增量后的栈指针

## 4.2 逻辑设计和硬件控制语言 HCL

### 4.2.1 逻辑门

- 逻辑门是数字电路的基本计算单元
- 它们产生的输出，等于它们输入位值的某个布尔函数
- 逻辑门总是活动的，一旦一个门的输入变化了，在很短的时间内，输出就会相应的变化

### 4.2.2 组合电路和 HCL 布尔表达式

将很多的逻辑门组合成一个网，就能构建计算块，称为*组合电路*。如何构建这些网有几个限制：
- 每个逻辑门的输入必须连接到下述选项之一：
  - 一个系统输入（称为主输入）
  - 某个存储器单元的输出
  - 某个逻辑门的输出
- 两个或多个逻辑门的输出不能连接在一起，否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障
- 这个网必须是无环的，有环的回路会导致该网络计算的函数有歧义

HCL 表达式很清楚地表明了组合逻辑电路和 C 语言中逻辑表达式的对应之处，它们都是用布尔操作来对输入进行计算的函数

### 4.2.3 字级的组合电路和 HCL 整数表达式

通常，我们设计能对数据字进行操作的电路

多路复用器：根据输入控制信号的值，从一组不同的数据信号中选出一个
- 在 HCL 中用情况表达式（case expression）来描述多路复用函数
- 不要求不同的选择表达式之间互斥

### 4.2.4 集合关系

`iexpr in { iexpr1, iexpr2, ..., iexprn }`

### 4.2.5 存储器和时钟

组合电路从本质上讲，不存储任何信息。它们只是简单的响应输入信号，产生等于输入的某个函数的输出

为了产生时序电路（有状态并且在这个状态上进行计算的系统），我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两种存储器设备：
- 时钟寄存器（简称寄存器）：存储单个位或字，时钟信号控制寄存器加载输入值
  - 寄存器是作为电路不同部分中的组合逻辑间的屏障，每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出
- 随机访问存储器（简称内存）：存储多个字，用地址来选择该读或写哪个字。例如：
  - 处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字
  - 寄存器文件，在此，寄存器标示符作为地址
    - 寄存器文件有读端口和写端口
    - 虽然寄存器文件不是组合电路，因为它有内部存储。但在我们的实现中，从寄存器读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块
    - 向寄存器文件写入字是时钟信号控制的，控制方式类似于将值加载到时钟寄存器

硬件和机器级编程中寄存器所指代的：
- 硬件寄存器：寄存器直接将它的输入和输出线连接到电路的其他部分
- 程序寄存器：寄存器代表的是 CPU 中为数不多可寻址的字，这里的地址是寄存器 ID

## 4.3 Y86-64 的顺序实现

SEQ：顺序处理器，每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步骤。不过这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受

### 4.3.1 将处理组织成阶段

处理一条指令包括很多操作，将它们组织成统一的阶段序列：
- 取指（fetch）：从内存读取指令字节，地址为 PC 的值。
  - 从指令中抽取出指令指示符（包括指令代码 `icode` 和指令功能 `ifun`）、寄存器指示符 `rA rB`、常数字 `valC`
  - 计算当前指令的下一条指令的地址 `valP` = PC + 已取出指令的长度
- 译码（decode）：从寄存器文件读入最多两个操作数，通常读入指令 `rA rB` 字段指明的寄存器，不过有些指令是读 `%rsp` 的
- 执行（execute）：算术逻辑单元 ALU 执行指令指明的操作（根据 `ifun`）/ 计算内存引用的有效地址 / 增加或减少栈指针
  - 得到的值称为 `valE`
  - 在此，也可能设置条件码 `CC`
  - 对条件传送指令来说，这一阶段会检验条件码和传送条件，如果条件成立，则更新目标寄存器；对于跳转指令来说，这一阶段决定是不是应该选择分支
- 访存（memory）：将数据写入内存 / 从内存中读出数据，读出的值为 `valM`
- 写回（write back）：最多可以写两个结果到寄存器文件
- 更新 PC（PC update）：将 PC 设置成下一条指令的地址

目标是使硬件数量尽可能少，并且最终把它映射到一个二位的集成电路芯片的表面。在设计硬件时，一个非常简单而一致的结构是非常重要的，降低复杂度的一种方法是让不同的指令共享尽量多的硬件

对于前面定义的 Y86-64 指令集，可以写出每种指令所需的处理：

`OPq rA rB`：整数和逻辑运算
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valP <- PC + 2
- 译码：
  - valA <- R[rA]
  - valB <- R[rB]
- 执行：
  - valE <- valB OP valA
  - set CC
- 访存：无
- 写回：
  - R[rB] <- valE
- 更新 PC：
  - PC <- valP

`rrmovq rA rB`：寄存器-寄存器传送
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valP <- PC + 2
- 译码：
  - valA <- R[rA]
- 执行：
  - valE <- 0 + valA
- 访存：无
- 写回：
  - R[rB] <- valE
- 更新 PC：
  - PC <- valP

`irmovq V rB`：立即数-寄存器传送
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valC <- M8[PC + 2]（注意这里取出了一个 8 字节的立即数，因此后面 PC + 10）
  - valP <- PC + 10
- 译码：无
- 执行：
  - valE <- 0 + valC
- 访存：无
- 写回：
  - R[rB] <- valE
- 更新 PC：
  - PC <- valP

`rmmovq rA D(rB)`：寄存器-内存传送
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valC <- M8[PC + 2]
  - valP <- PC + 10
- 译码：
  - valA <- R[rA]
  - valB <- R[rB]
- 执行：
  - valE <- valB + valC
- 访存：
  - M8[valE] <- valA
- 写回：无
- 更新 PC：
  - PC <- valP

`mrmovq D(rB) rA`：内存-寄存器传送
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valC <- M8[PC + 2]
  - valP <- PC + 10
- 译码：
  - valB <- R[rB]
- 执行：
  - valE <- valB + valC
- 访存：
  - valM <- M8[valE]
- 写回：
  - R[rA] <- valM
- 更新 PC：
  - PC <- valP

`pushq rA`
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valP <- PC + 2
- 译码：
  - valA <- R[rA]
  - valB <- R[%rsp]
- 执行：
  - valE <- valB + (-8)
- 访存：
  - M8[valE] <- valA
- 写回：（注意，栈指针的更新实际上是在内存操作完成之后才进行的）
  - R[%rsp] <- valE
- 更新 PC：
  - PC <- valP

`popq rA`
- 取指：
  - icode:ifun <- M1[PC]
  - rA:rB <- M1[PC + 1]
  - valP <- PC + 2
- 译码：（这里读了两次栈指针，为了使后面的流程跟其他指令更相似）
  - valA <- R[%rsp]
  - valB <- R[%rsp]
- 执行：
  - valE <- valB + 8
- 访存：
  - valM <- M8[valA]
- 写回：
  - R[%rsp] <- valE
  - R[rA] <- valM
- 更新 PC：
  - PC <- valP

`jxx Dest`：跳转指令
- 取指：
  - icode:ifun <- M1[PC]
  - valC <- M8[PC + 1]
  - valP <- PC + 9
- 译码：无
- 执行：（根据条件码和跳转条件来确定是否要选择分支）
  - Cnd <- Cond(CC, ifun)
- 访存：无
- 写回：无
- 更新 PC：
  - PC <- Cnd ? valC : valP

`call Dest`：存储返回地址，跳转到 Dest
- 取指：
  - icode:ifun <- M1[PC]
  - valC <- M8[PC + 1]
  - valP <- PC + 9
- 译码：
  - valB <- R[%rsp]
- 执行：
  - valE <- valB + (-8)
- 访存：
  - M8[valE] <- valP
- 写回：
  - R[%rsp] <- valE
- 更新 PC：
  - PC <- valC

`ret`
- 取指：
  - icode:ifun <- M1[PC]
  - valP <- PC + 1
- 译码：
  - valA <- R[%rsp]
  - valB <- R[%rsp]
- 执行：
  - valE <- valB + 8
- 访存：
  - valM <- M8[valA]
- 写回：
  - R[%rsp] <- valE
- 更新 PC：
  - PC <- valM

### 4.3.2 SEQ 硬件结构

- 取指：将程序计数器作为地址，指令内存读取指令的字节。PC 增加器计算 valP
- 译码：寄存器文件有两个读端口 A 和 B，从这两个端口同时读寄存器值 valA 和 valB
- 执行：
  - 执行阶段会根据指令的类型，将算术/逻辑单元（ALU）用于不同的目的。对整数操作，它要执行指令所指定的运算；对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单的加 0，将输入传递到输出。
  - 条件码寄存器（CC）有三个条件码位。ALU 负责计算条件码的新值。当执行条件传送指令时，会根据条件码和传送条件来计算决定是否更新目标寄存器；同样，当执行跳转指令时，会根据条件码和跳转类型来计算分支信号 Cnd
- 访存：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。
- 写回：寄存器文件有两个写端口，端口 E 用来写 ALU 计算出来的值，端口 M 用来写从数据内存读出的值
- PC 更新：程序计数器的新值选择自：
  - 下一条指令的地址 valP
  - 调用指令或跳转指令指定的目标地址 valC
  - 从内存读取的返回地址 valM

### 4.3.3 SEQ 的时序

一个时钟变化会引发一个经过组合逻辑的流，来执行整个指令
- 组合逻辑：不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播
- 随机访问存储器（寄存器文件、指令内存、数据内存）：
  - 读 可以看成组合逻辑，根据地址输入产生输出字（指令内存只有读操作）
  - 写：一个时钟信号控制
    - 寄存器文件：寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器
    - 数据内存：只有 `rrmovq pushq call` 时会写。
- 程序计数器、条件码寄存器：一个时钟信号控制

组织计算的原则：从不回读。处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。

用时钟来控制状态单元的更新 + 值通过组合逻辑来传播 -> 足够控制我们 SEQ 实现中每条指令执行的计算。每次时钟由低变高时，处理器开始执行一条新指令

### 4.3.4 SEQ 阶段的实现

## 4.4 流水线的通用原理

流水线化的一个重要特性就是提高了系统的*吞吐量*，不过它也会轻微地增加*延迟*

### 4.4.1 计算流水线

### 4.4.2 流水线操作的详细说明

- 流水线阶段之间的指令转移是通过时钟信号来控制的
- 各阶段之间放置流水线寄存器，每阶段的输出结果存放到流水线寄存器中，并成为下一阶段的输入
- 减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态
- 当如果时钟运行得太快，值可能来不及通过组合逻辑，当时钟上升时，寄存器的输入还不是合法的值

### 4.4.3 流水线的局限性

- 不一致的划分
  - 流水线每阶段的延迟不一致，而运行时钟的速率由最慢的阶段的延迟限制，就会导致有些阶段空闲
  - 而对于硬件设计来说，将系统计算设计划分成一组具有相同延迟的阶段很困难。通常，处理器中的某些硬件单元，如 ALU 和内存，是不能被划分为多个延迟较小的单元的，这就使得创建一组平衡的阶段非常困难
- 流水线过深，收益反而下降
  - 在组合逻辑被分成较小的块时，流水线寄存器更新引起的延迟成为了流水线吞吐量的制约因素
  - 现代处理器采用了很深（15+）流水线，处理器架构师将指令的执行划分成很多非常简单的步骤，这样一来每个阶段的延迟就很小。电路设计者小心地设计流水线寄存器，使其延迟尽可能得小。芯片设计者也必须小心地设计时钟传播网络，以保证时钟在整个芯片上同时改变

### 4.4.4 带反馈的流水线系统

相邻指令之间可能是相关的：
- 数据相关：下一条指令会用到这一条指令计算出的结果
- 控制相关：一条指令要确定下一条指令的位置，例如跳转、调用、返回指令

未流水线化的 SEQ 是带*反馈*的，每一条指令的结果都反馈给下一条指令。而引入流水线技术后，则必须考虑反馈的影响

## 4.5 Y86-64 的流水线实现

### 4.5.1 SEQ+：重新安排计算阶段

*电路重定时*改进：将更新 PC 阶段放在时钟周期开始时执行，而不是结束时
- 硬件上没有 PC 寄存器，而是根据前一条指令保存下来的一些状态信息来动态地计算 PC
- “我们可以以一种与 ISA 隐含着的概念模型不同的方式来实现处理器，只要处理器能正确地执行任意的机器语言程序。我们不需要将状态编码成程序员可见的状态指定的形式，只要处理器能够为任意的程序员可见状态（例如 PC）产生正确的值
- 重定时改变了一个系统的状态表示，但并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟

### 4.5.2 插入流水线寄存器

在 SEQ+ 中插入流水线寄存器，形成 PIPE-：
- F 保存程序计数器的预测值
- D 位于取指和译码阶段之间，保存关于最新取出的指令的信息，即将由译码阶段进行处理
- E 位于译码和执行阶段之间，保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理
- M 位于执行和访存阶段之间，保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息
- W 位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成 ret 指令时，它还要向 PC 选择逻辑提供返回地址

### 4.5.3 对信号进行重新排列和标号

通过在信号名前面加上大写的流水线寄存器名作为前缀，存储在流水线寄存器中的信号可以被唯一标识，如 `D_Stat E_Stat M_Stat W_Stat`

还需要引用某些在一个阶段内刚刚计算出来的信号，它们的命名是在信号名前面加上小写的阶段名的第一个字母作为前缀，如 `f_stat m_stat`

我们要保存处于一个流水线阶段中的指令的所有信息

仔细确认信号是如何使用的，通过*合并信号*来减少寄存器状态和线路数量

### 4.5.4 预测下一个 PC

流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。要做到这一点，我们就必须在取出当前指令之后马上确定下一条指令的位置。存在的问题：
- 条件分支指令，需要在指令通过执行阶段后才能知道是否选择分支
- ret 指令，需要在指令通过访存阶段才能确定返回地址
- 其他指令，通过取指阶段计算出的信息能够确定下一条指令的地址。
  - call jmp：下一条指令的地址是指令中的常数字 valC
  - 其他指令：valP

*分支预测*：猜测条件分支的方向并根据猜测开始取指。可以预测选择分支（valC），也可以预测没有选择分支（valP），但都需要处理预测错误的情况（因为此时已经取出并执行了部分指令）

分支预测策略：
- 总是选择（always taken）
- 从不选择（never taken）
- 反向选择、正向不选择（backward taken, forward not-taken）：但分支地址比下一条地址低时就预测选择分支，而分支地址比较高时就预测不选择分支

预测 ret 指令的新 PC 值：因为大多数程序的过程调用和返回是成对出现的，所以可以在取指单元中维护一个硬件栈保存每次 call 时的返回地址，ret 时弹出。同样需要处理预测错误时的情况

### 4.5.5 流水线冒险

*数据相关*和*控制相关*会导致流水线产生计算错误，称为*冒险*（hazard）。冒险同样分为数据冒险和控制冒险

数据冒险：如果一条指令的操作数被它前面三条指令中的任意一条改变的话，都会出现数据冒险。因为我们的流水线化的处理器是在译码阶段从寄存器文件读取指令的操作数，而要到三个周期以后的写回阶段，才会将指令的结果写到寄存器文件
- 用*暂停*（stalling）来避免数据冒险
  - 停止流水线中一条或多条指令，直到冒险条件不再满足
  - 把指令阻塞在译码阶段：在执行阶段插入气泡
  - 后面的指令：阻塞在取指阶段，方法是保持 PC 不变，会不断取指同一条指令
- 用*转发*来避免数据冒险
  - 数据转发/旁路：将结果值直接从一个流水线阶段传到较早阶段
  - 将 ALU 产生的以及其目标为写端口 E 的值进行转发
  - 转发从内存中读出的以及其目标为写端口 M 的值
  - 在各个转发源之间建立优先级关系
- 加载/使用数据冒险
  - 因为内存读在流水线发生的比较晚，单纯使用转发无法解决（转发需要将值送回过去的时间）
  - *加载互锁*：使用暂停和转发结合
- 避免控制冒险
  - ret：插入气泡
  - 处理预测错误的分支：预测的结果会在两个阶段后给出，这之间的两个指令都未到达执行阶段，因此只需要给这两个错误的指令插入气泡，*取消*这两条预测错误的指令

### 4.5.6 异常处理

异常：
- halt 指令
- 有非法指令和功能码组合的指令
- 取指或数据读写试图访问一个非法地址
- 外部异常：例如处理器收到一个网络接口新包的信号，或是一个用户点击鼠标按钮的信号

我们希望当处理器遇到异常时，会停止，设置适当的状态码，看上去应该是到异常指令之前的所有指令都已经完成，而其后的指令都不应该对程序员可见的状态产生任何影响。在一个更完整的设计中，处理器会继续调用*异常处理程序*

异常处理的细节问题：
- 可能同时有多条指令会引起异常
  - 向操作系统报告的异常应当是由流水线中最深的指令引起的异常
  - 解决：当流水线中有一个或多个阶段出现异常时，信息只是简单地存放在流水线寄存器的状态字段中。异常事件不会对流水线中的指令流有任何影响，除了会禁止流水线中后面的指令更新程序员可见的状态，直到异常指令到达最后的流水线阶段。因为指令到达写回阶段的顺序与它们在非流水线化的处理器中执行的顺序相同，使用我们可以保证第一条遇到异常的指令第一个到达写回阶段，此时停止程序执行，报告异常状态
- 当首先取出一条指令，开始执行时，导致了一个异常，而后来由于分支预测错误，取消了该指令
  - 此时需要避免出现异常
  - 解决：如果取出了某条指令，过后又取消了，那么所有关于这条指令的异常状态信息也都会被取消
- 一条指令导致了一个异常，它后面的指令在异常指令完成之前改变了部分状态
  - 要求异常指令之后的所有指令都不能影响系统状态
  - 解决：当处于访存或写回阶段的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或是数据内存

在每个流水线寄存器中包括一个状态码 Stat，如果一条指令在处理中于某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现出现了异常，并停止执行

### 4.5.7 PIPE 各阶段的实现

### 4.5.8 流水线控制逻辑

流水线控制逻辑必须处理下面四种控制情况，这些情况是其他机制（例如数据转发和分支预测）不能处理的：
- 加载/使用冒险：在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期
- 处理 ret：流水线必须暂停直到 ret 指令到达写回阶段
- 预测错误的分支：在分支逻辑发现不应该选择分支之前，分支目标处的几条指令已经进入流水线了。必须取消这些指令，并从跳转指令后面的那条指令开始取消
- 异常：当一条指令导致异常，我们想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段时，停止执行

期望的处理：
- 加载/使用冒险：需要发现冒险的情况，保持流水线寄存器 F 和 D 固定不变，并且在执行阶段中插入气泡
- ret：流水线要停顿 3 个时钟周期，直到 ret 指令经过访存阶段，读出返回地址
- 分支预测错误：当跳转指令到达执行阶段就可以检测到预测错误，然后在下一个时钟周期，控制逻辑就会在译码和执行段插入气泡，取消两条不正确的已取指令。在同一个时钟周期，流水线将正确的指令读取到取指阶段
- 异常：每个流水线寄存器中都包含一个状态码 stat，随着每条指令经过流水线阶段，它会记录指令的状态。当异常指令到达访存阶段时，采取措施防止后面的指令修改程序员可见的状态：1.禁止执行阶段中的指令设置条件码；2.向内存阶段插入气泡，以禁止向数据内存写入；3.当写回阶段中有异常指令时，暂停写回阶段，因而暂停了流水线

发现特殊控制条件：
- 加载/使用冒险：执行阶段的指令类型为 mrmovq/popq，且它的目的寄存器与译码阶段中指令的源寄存器有相同的
- ret：译码/执行/访存阶段的指令码为 ret
- 预测错误的分支：跳转指令处于执行阶段，且信号 e_End 指明是否需要选择分支
- 异常：访存阶段的 stat 为异常

控制条件的组合：
- 组合 A：执行阶段有一条不选择分支的跳转指令（预测错误），而译码阶段有一条 ret 指令（ret）。流水线控制逻辑应该发现分支预测错误，因此要取消 ret 指令
- 组合 B：加载指令设置寄存器 %rsp，然后 ret 指令用这个寄存器作为源操作数（加载/使用冒险 + ret），因为它必须从栈中弹出返回地址。流水线控制逻辑应该将 ret 指令阻塞在译码阶段

### 4.5.9 性能分析

所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能够实现每个时钟周期发射一条新指令的目标。可以通过确定往流水线中插入气泡的效率来衡量这种效率的损失：
- ret：3 个气泡
- 加载/使用冒险：1 个气泡
- 预测错误的分支：2 个气泡

分析方法：
- 可以通过计算 PIPE 执行一条指令所需要的平均时钟周期数的估计值，来量化这些处罚对整体性能的影响
- 忽略异常带来的性能损失，假设在处理器上运行某个基准程序（这个程序中 ret/加载使用冒险/预测错误的分支 的频率分别为 xxx），那么可以推导出处理器总共需要多少时间来执行多少条指令，从而可以计算 CPI（每指令周期数）

### 4.5.10 未完成的工作

- 多周期指令：整数乘法和除法，浮点运算等。
  - 简单地扩展执行阶段逻辑的功能，添加一些整数和浮点运算单元。但一条指令在执行阶段逗留多个时钟周期，会导致取指和译码阶段暂停，因而性能不是很好
  - 采用独立于主流水线的特殊硬件功能单元来处理较为复杂的操作，通常有一个功能单元执行整数乘法和除法，还有一个来执行浮点操作。不同单元的操作必须同步，以避免出错（需要经常使用转发，将结果从系统的一个部分传递到其他部分。也需要配合暂停和流水线控制等处理特殊情况）
- 与存储系统的接口
  - 在对 PIPE 的描述中，我们是以存储器位置的虚拟地址来引用它们的，这要求在执行实际的读或写操作之前，要将虚拟地址翻译成物理地址。
  - 处理器的存储系统是有多种硬件存储器和管理虚拟内存的操作系统软件共同组成的，存储系统被组织成层次结构
  - 高速缓存不命中时，处理器需要*暂停*（短时间内可以找到命中结果）
  - 另一种情况是被引用的存储器位置实际上存储在磁盘存储器上，此时硬件会产生一个缺页*异常*，然后交给操作系统处理...（长时间才能找到命中结果）
